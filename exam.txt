package com.example.demo.service;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.stereotype.Service;
import com.example.demo.bot.command.AddCommand.AddState;

@Service
public class AddStateService {

    private final Map<Long, AddState> userStates = new ConcurrentHashMap<>();

    public AddState getState(Long userId) {
        return userStates.get(userId);
    }

    public void putState(Long userId, AddState state) {
        userStates.put(userId, state);
    }

    public void removeState(Long userId) {
        userStates.remove(userId);
    }
}
package com.example.demo.service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import org.springframework.stereotype.Service;
import com.example.demo.entity.Category;
import com.example.demo.entity.Task;
import com.example.demo.entity.User;
import com.example.demo.entity.enums.TaskStatus;
import com.example.demo.repository.TaskRepository;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Service
public class TaskService {

    private final TaskRepository taskRepository;

    public List<Task> getActiveTasksForUser(User user) {
        return taskRepository.findByUserAndStatusOrderByDeadlineAsc(user, TaskStatus.ACTIVE);
    }

    public List<Task> getAllTasksForUser(User user) {
        return taskRepository.findByUserOrderByCreatedAtDesc(user);
    }

    public Task save(Task task) {
        return taskRepository.save(task);
    }

    public Optional<Task> findById(Long id) {
        return taskRepository.findById(id);
    }

    public void completeTask(Long taskId, User user) {
        findById(taskId).ifPresent(task -> {
            if (task.getUser().getId().equals(user.getId())) {
                task.setStatus(TaskStatus.COMPLETED);
                task.setCompletedAt(LocalDateTime.now());
                save(task);
            }
        });
    }

    public Task createTask(User user, Category category, String title, LocalDateTime deadline) {
        Task task = Task.builder().user(user).category(category).title(title).deadline(deadline)
                .status(TaskStatus.ACTIVE).build();
        return save(task);
    }
}
package com.example.demo.service;

import org.springframework.stereotype.Service;
import com.pengrad.telegrambot.TelegramBot;
import com.pengrad.telegrambot.model.request.Keyboard;
import com.pengrad.telegrambot.request.SendMessage;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Service
public class MessageService {

    private final TelegramBot telegramBot;

    public void sendMessage(Long chatId, String text) {
        telegramBot.execute(new SendMessage(chatId, text));
    }

    public void sendMessage(Long chatId, String text, Keyboard keyboard) {
        telegramBot.execute(new SendMessage(chatId, text).replyMarkup(keyboard));
    }
}
package com.example.demo.service;

import java.time.LocalDateTime;
import java.util.List;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import com.example.demo.entity.Task;
import com.example.demo.entity.enums.TaskStatus;
import com.example.demo.repository.TaskRepository;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Service
public class NotificationService {

    private final TaskRepository taskRepository;
    private final MessageService messageService;

    @Scheduled(fixedRate = 60000)
    public void sendReminders() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime in5min = now.plusMinutes(5);
        List<Task> upcoming =
                taskRepository.findByStatusAndDeadlineBetween(TaskStatus.ACTIVE, now, in5min);

        for (Task task : upcoming) {
            messageService.sendMessage(task.getUser().getId(), "Напоминание! Задача \""
                    + task.getTitle() + "\" скоро дедлайн: " + task.getDeadline());
        }
    }
}
package com.example.demo.service;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Service;
import com.example.demo.entity.Category;
import com.example.demo.repository.CategoryRepository;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Service
public class CategoryService {

    private final CategoryRepository categoryRepository;

    public List<Category> getAllCategories() {
        return categoryRepository.findAll();
    }

    public Optional<Category> findByName(String name) {
        return categoryRepository.findByName(name);
    }

    public Category save(Category category) {
        return categoryRepository.save(category);
    }

    @EventListener(ApplicationReadyEvent.class)
    public void initDefaultCategories() {
        List<String> defaultNames =
                Arrays.asList("Аналитика", "Разработка", "Дизайн", "Тестирование", "Другое");
        defaultNames.forEach(name -> {
            if (findByName(name).isEmpty()) {
                save(Category.builder().name(name).build());
            }
        });
    }
}
package com.example.demo.service;

import java.util.Optional;
import org.springframework.stereotype.Service;
import com.example.demo.entity.User;
import com.example.demo.repository.UserRepository;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Service
public class UserService {

    private final UserRepository userRepository;

    public User save(User user) {
        return userRepository.save(user);
    }

    public User getOrCreateUser(Long telegramId, String username, String firstName) {
        Optional<User> userOpt = userRepository.findById(telegramId);
        User user;
        if (userOpt.isPresent()) {
            user = userOpt.get();
            if (!user.getUsername().equals(username) || !user.getFirstName().equals(firstName)) {
                user.setUsername(username);
                user.setFirstName(firstName);
                save(user);
            }
        } else {
            user = User.builder().id(telegramId).username(username).firstName(firstName).build();
            save(user);
        }
        return user;
    }
}
package com.example.demo.bot;

import java.util.List;
import java.util.stream.Collectors;
import org.springframework.stereotype.Component;
import com.example.demo.bot.command.AddCommand;
import com.example.demo.bot.command.Command;
import com.example.demo.entity.User;
import com.example.demo.service.AddStateService;
import com.example.demo.service.MessageService;
import com.example.demo.service.TaskService;
import com.example.demo.service.UserService;
import com.pengrad.telegrambot.TelegramBot;
import com.pengrad.telegrambot.UpdatesListener;
import com.pengrad.telegrambot.model.BotCommand;
import com.pengrad.telegrambot.model.Update;
import com.pengrad.telegrambot.request.AnswerCallbackQuery;
import com.pengrad.telegrambot.request.SetMyCommands;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Component
public class Bot implements UpdatesListener {

    private final TelegramBot telegramBot;
    private final List<Command> commands;
    private final AddCommand addCommand;
    private final AddStateService addStateService;
    private final MessageService messageService;
    private final UserService userService;
    private final TaskService taskService;

    @PostConstruct
    public void init() {
        registerCommands();
        telegramBot.setUpdatesListener(this);
    }

    private void registerCommands() {
        List<BotCommand> botCommands =
                commands.stream().map(cmd -> new BotCommand(cmd.command(), cmd.description()))
                        .collect(Collectors.toList());

        telegramBot.execute(new SetMyCommands(botCommands.toArray(new BotCommand[0])));
    }

    @Override
    public int process(List<Update> updates) {
        for (Update update : updates) {
            if (update.callbackQuery() != null) {
                handleCallback(update);
            } else if (update.message() != null && update.message().text() != null) {
                handleMessage(update);
            }
        }
        return UpdatesListener.CONFIRMED_UPDATES_ALL;
    }

    private void handleMessage(Update update) {
        String text = update.message().text().trim();
        Long telegramId = update.message().from().id();
        Long chatId = update.message().chat().id();

        if (text.startsWith("/")) {
            addStateService.removeState(telegramId);
            String cmd = text.split(" ")[0];
            commands.stream().filter(c -> c.command().equalsIgnoreCase(cmd)).findFirst()
                    .ifPresentOrElse(c -> c.handle(update), () -> messageService.sendMessage(chatId,
                            "Неизвестная команда. Используйте доступные команды."));
        } else {
            if (addStateService.getState(telegramId) != null) {
                addCommand.handle(update);
            } else {
                messageService.sendMessage(chatId,
                        "Пожалуйста, используйте команды для взаимодействия.");
            }
        }
    }

    private void handleCallback(Update update) {
        var callback = update.callbackQuery();
        String data = callback.data();
        Long chatId = callback.message().chat().id();
        Long telegramId = callback.from().id();
        String username = callback.from().username() != null ? callback.from().username()
                : callback.from().firstName();
        String firstName = callback.from().firstName();

        User user = userService.getOrCreateUser(telegramId, username, firstName);

        if (data.startsWith("complete:")) {
            Long taskId = Long.parseLong(data.replace("complete:", ""));
            taskService.completeTask(taskId, user);
            messageService.sendMessage(chatId, "Задача #" + taskId + " выполнена");
        }

        telegramBot.execute(new AnswerCallbackQuery(callback.id()));
    }
}
package com.example.demo.bot.command;

import com.pengrad.telegrambot.model.Update;

public interface Command {
    String command();

    String description();

    void handle(Update update);
}
package com.example.demo.bot.command;

import java.time.format.DateTimeFormatter;
import java.util.List;
import org.springframework.stereotype.Component;
import com.example.demo.entity.Task;
import com.example.demo.entity.User;
import com.example.demo.service.MessageService;
import com.example.demo.service.TaskService;
import com.example.demo.service.UserService;
import com.example.demo.util.UpdateUtils;
import com.pengrad.telegrambot.model.Update;
import com.pengrad.telegrambot.model.request.InlineKeyboardButton;
import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Component
public class ListCommand implements Command {

    private final TaskService taskService;
    private final UserService userService;
    private final MessageService messageService;

    @Override
    public String command() {
        return "/list";
    }

    @Override
    public String description() {
        return "Показать список активных задач";
    }

    @Override
    public void handle(Update update) {
        User user = UpdateUtils.getUser(userService, update);
        Long chatId = UpdateUtils.getChatId(update);
        List<Task> activeTasks = taskService.getActiveTasksForUser(user);

        if (activeTasks.isEmpty()) {
            messageService.sendMessage(chatId, "У тебя нет активных задач.");
            return;
        }

        StringBuilder sb = new StringBuilder("Твои активные задачи:\n");
        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("dd.MM.yyyy HH:mm");
        for (Task task : activeTasks) {
            sb.append(task.getId()).append(": ").append(task.getTitle()).append(" (")
                    .append(task.getCategory().getName()).append(") - дедлайн: ")
                    .append(task.getDeadline().format(fmt)).append("\n");
        }

        InlineKeyboardMarkup inlineKeyboard = new InlineKeyboardMarkup();
        for (Task task : activeTasks) {
            inlineKeyboard.addRow(new InlineKeyboardButton("Выполнить: " + task.getTitle())
                    .callbackData("complete:" + task.getId()));
        }

        messageService.sendMessage(chatId, sb.toString(), inlineKeyboard);
    }
}
package com.example.demo.bot.command;

import java.time.format.DateTimeFormatter;
import java.util.List;
import org.springframework.stereotype.Component;
import com.example.demo.entity.Task;
import com.example.demo.entity.User;
import com.example.demo.service.MessageService;
import com.example.demo.service.TaskService;
import com.example.demo.service.UserService;
import com.example.demo.util.UpdateUtils;
import com.pengrad.telegrambot.model.Update;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Component
public class HistoryCommand implements Command {

    private final TaskService taskService;
    private final UserService userService;
    private final MessageService messageService;

    @Override
    public String command() {
        return "/history";
    }

    @Override
    public String description() {
        return "Показать историю всех задач";
    }

    @Override
    public void handle(Update update) {
        User user = UpdateUtils.getUser(userService, update);
        Long chatId = UpdateUtils.getChatId(update);
        List<Task> allTasks = taskService.getAllTasksForUser(user);

        if (allTasks.isEmpty()) {
            messageService.sendMessage(chatId, "У тебя нет задач в истории.");
        } else {
            StringBuilder sb = new StringBuilder("Все задачи:\n");
            DateTimeFormatter fmt = DateTimeFormatter.ofPattern("dd.MM.yyyy HH:mm");

            for (Task task : allTasks) {
                sb.append(task.getId()).append(": ").append(task.getTitle()).append(" (")
                        .append(task.getCategory().getName()).append(") - статус: ")
                        .append(task.getStatus()).append(", дедлайн: ")
                        .append(task.getDeadline().format(fmt));

                if (task.getCompletedAt() != null) {
                    sb.append(", завершено: ").append(task.getCompletedAt().format(fmt));
                }
                sb.append("\n");
            }

            messageService.sendMessage(chatId, sb.toString());
        }
    }
}
package com.example.demo.bot.command;

import org.springframework.stereotype.Component;
import com.example.demo.entity.User;
import com.example.demo.service.MessageService;
import com.example.demo.service.UserService;
import com.example.demo.util.UpdateUtils;
import com.pengrad.telegrambot.model.Update;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Component
public class StartCommand implements Command {

    private final UserService userService;
    private final MessageService messageService;

    @Override
    public String command() {
        return "/start";
    }

    @Override
    public String description() {
        return "Начало работы с ботом";
    }

    @Override
    public void handle(Update update) {
        User user = UpdateUtils.getUser(userService, update);
        Long chatId = UpdateUtils.getChatId(update);

        String welcomeMessage = "Привет, " + user.getFirstName() + "!\n\n"
                + "Я - твой Task Tracker бот.\n\n" + "Доступные команды:\n"
                + "/add - добавить новую задачу\n" + "/list - показать список активных задач\n"
                + "/history - показать историю задач\n";

        messageService.sendMessage(chatId, welcomeMessage);
    }
}
package com.example.demo.bot.command;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.List;
import org.springframework.stereotype.Component;
import com.example.demo.entity.Category;
import com.example.demo.entity.User;
import com.example.demo.service.AddStateService;
import com.example.demo.service.CategoryService;
import com.example.demo.service.MessageService;
import com.example.demo.service.TaskService;
import com.example.demo.service.UserService;
import com.example.demo.util.UpdateUtils;
import com.pengrad.telegrambot.model.Update;
import com.pengrad.telegrambot.model.request.ReplyKeyboardMarkup;
import com.pengrad.telegrambot.model.request.ReplyKeyboardRemove;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Component
public class AddCommand implements Command {

    private final CategoryService categoryService;
    private final TaskService taskService;
    private final UserService userService;
    private final MessageService messageService;
    private final AddStateService addStateService;

    @Override
    public String command() {
        return "/add";
    }

    @Override
    public String description() {
        return "Добавить новую задачу";
    }

    @Override
    public void handle(Update update) {
        Long chatId = UpdateUtils.getChatId(update);
        String text = update.message().text().trim();
        User user = UpdateUtils.getUser(userService, update);

        AddState state = addStateService.getState(user.getId());

        if (text.equals("/add")) {
            List<Category> categories = categoryService.getAllCategories();
            if (categories.isEmpty()) {
                messageService.sendMessage(chatId, "Нет доступных категорий.");
                return;
            }
            ReplyKeyboardMarkup markup = new ReplyKeyboardMarkup(
                    categories.stream().map(Category::getName).toArray(String[]::new));
            markup.resizeKeyboard(true).selective(true);

            messageService.sendMessage(chatId, "Выбери категорию для новой задачи:", markup);
            addStateService.putState(user.getId(), new AddState(AddStep.WAITING_CATEGORY));
            return;
        }

        if (state == null) {
            messageService.sendMessage(chatId, "Ошибка! Начни заново с /add");
            return;
        }

        switch (state.step) {
            case WAITING_CATEGORY:
                Category category = categoryService.findByName(text).orElse(null);
                if (category == null) {
                    messageService.sendMessage(chatId,
                            "Категория не найдена. Попробуй выбрать из списка.");
                    return;
                }
                state.categoryName = category.getName();
                state.step = AddStep.WAITING_TITLE;
                messageService.sendMessage(chatId, "Теперь введи название задачи:",
                        new ReplyKeyboardRemove(true));
                return;

            case WAITING_TITLE:
                state.title = text;
                state.step = AddStep.WAITING_DEADLINE;
                messageService.sendMessage(chatId,
                        "Теперь введи дедлайн в формате yyyy-MM-dd HH:mm (например, 2025-09-20 18:00):");
                return;

            case WAITING_DEADLINE:
                try {
                    LocalDateTime deadline = LocalDateTime.parse(text,
                            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"));
                    Category cat = categoryService.findByName(state.categoryName).orElseThrow();
                    taskService.createTask(user, cat, state.title, deadline);
                    messageService.sendMessage(chatId, "Задача успешно добавлена");
                    addStateService.removeState(user.getId());
                } catch (DateTimeParseException e) {
                    messageService.sendMessage(chatId,
                            "Неверный формат дедлайна. Попробуй снова (yyyy-MM-dd HH:mm):");
                }
                return;
        }

        messageService.sendMessage(chatId, "Ошибка! Начни заново с /add");
    }

    public static class AddState {
        AddStep step;
        String categoryName;
        String title;

        AddState(AddStep step) {
            this.step = step;
        }
    }

    public enum AddStep {
        WAITING_CATEGORY, WAITING_TITLE, WAITING_DEADLINE
    }
}
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@EnableScheduling
@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}

}
package com.example.demo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "categories")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "name", unique = true, nullable = false, length = 100)
    private String name;
}
package com.example.demo.entity.enums;

public enum TaskStatus {
    ACTIVE, COMPLETED
}
package com.example.demo.entity;

import java.time.LocalDateTime;
import com.example.demo.entity.enums.TaskStatus;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "tasks")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Task {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id", nullable = false)
    private Category category;

    @Column(name = "title", nullable = false, length = 500)
    private String title;

    @Column(name = "deadline", nullable = false)
    private LocalDateTime deadline;

    @Builder.Default
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private TaskStatus status = TaskStatus.ACTIVE;

    @Column(name = "completed_at")
    private LocalDateTime completedAt;

    @Column(name = "created_at", columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private LocalDateTime createdAt;
}
package com.example.demo.entity;

import java.time.LocalDateTime;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {

    @Id
    @Column(name = "id")
    private Long id;

    @Column(name = "username", length = 255)
    private String username;

    @Column(name = "first_name", length = 255)
    private String firstName;

    @Column(name = "created_at", columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    private LocalDateTime createdAt;
}
package com.example.demo.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.example.demo.entity.Category;

@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    Optional<Category> findByName(String name);
}
package com.example.demo.repository;

import java.time.LocalDateTime;
import java.util.List;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.example.demo.entity.Task;
import com.example.demo.entity.User;
import com.example.demo.entity.enums.TaskStatus;

@Repository
public interface TaskRepository extends JpaRepository<Task, Long> {

    @EntityGraph(attributePaths = {"category"})
    List<Task> findByUserAndStatusOrderByDeadlineAsc(User user, TaskStatus status);

    @EntityGraph(attributePaths = {"category"})
    List<Task> findByUserOrderByCreatedAtDesc(User user);

    List<Task> findByStatusAndDeadlineBetween(TaskStatus status, LocalDateTime start,
            LocalDateTime end);
}
package com.example.demo.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.example.demo.entity.User;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
package com.example.demo.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.pengrad.telegrambot.TelegramBot;

@Configuration
public class BotConfig {

    @Bean
    public TelegramBot telegramBot(@Value("${bot.token}") String token) {
        return new TelegramBot(token);
    }
}
package com.example.demo.util;

import com.example.demo.entity.User;
import com.example.demo.service.UserService;
import com.pengrad.telegrambot.model.Update;

public class UpdateUtils {

    public static User getUser(UserService userService, Update update) {
        Long telegramId = update.message().from().id();
        String username =
                update.message().from().username() != null ? update.message().from().username()
                        : update.message().from().firstName();
        String firstName = update.message().from().firstName();
        return userService.getOrCreateUser(telegramId, username, firstName);
    }

    public static Long getChatId(Update update) {
        return update.message().chat().id();
    }
}
